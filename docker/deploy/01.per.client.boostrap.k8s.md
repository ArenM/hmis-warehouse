# Bootstrap a single client environment

Set the client and environment to what you want instead of `qa`

        export AWS_PROFILE=openpath
        export CLIENT=qa
        export ENVIRONMENT=production
	export NAMESPACE=$CLIENT-$ENVIRONMENT

## Make namespaces

       cat k8s/namespace.yml | envsubst | kubectl apply -f -

       echo set the default namespace
       kubectl config set-context --current --namespace=$NAMESPACE

# Make a service account (k8s side)

Fuzzy why we need this. It think it's just setting permissions on what the
ingree controllers can do.

Create a Kubernetes service account named alb-ingress-controller in the kube-system namespace, a cluster role,
and a cluster role binding for the ALB Ingress Controller to use with the
following command:

       cat k8s/rbac-role.yml | envsubst | kubectl apply -f -

## Make Service Account (AWS side)

Create an IAM role for the ALB ingress controller and attach the role to the
service account created in the previous step. If you didn't create your cluster
with eksctl, then use the instructions on the AWS Management Console or AWS CLI
tabs.

<pre>

eksctl create iamserviceaccount \
    --region us-east-1 \
    --name alb-ingress-controller \
    --namespace $NAMESPACE \
    --cluster openpath \
    --attach-policy-arn arn:aws:iam::153758321681:policy/ALBIngressControllerIAMPolicy \
    --override-existing-serviceaccounts \
    --approve

</pre>

# Deploy the ALB Ingress Controller

        cat k8s/alb-ingress-controller.yml | envsubst | kubectl apply -f -

# See it

kubectl cluster-info
kubectl get namespace


kubectl get pods
kubectl get services
kubectl get deployments

## WIP Deploy the app

        cat k8s/deployment.yml | envsubst | kubectl -f -
        cat k8s/service.yml | envsubst | kubectl -f -
        cat k8s/ingress.yml | envsubst | kubectl -f -

## WIP: Enable cluster logging

        Pueksctl utils update-cluster-logging --region=us-east-1 --cluster=openpath
